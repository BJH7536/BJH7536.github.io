---
title:  게임 개발을 위한 디자인 패턴들
date:   2024-03-03 +0900
categories: [디자인 패턴]
tags: [디자인 패턴, Unity, C#]
math: true
mermaid: true
---

> 위 글은 유니티에서 공식으로 제공하는 E Book을 기반으로 제가 번역, 공부하며 정리한 자료를 글로 남긴 것입니다.

## The Gang of Four
***"Gang of Four"(GoF)*** 는 오늘날의 많은 소프트웨어 디자인 패턴의 기원이 되는 핵심적인 작업, 
즉 *Erich Gamma, Richard Helm, Ralph Johnson, 그리고 John Vlissides* 에 의해 저술된 ***"Design Patterns: Elements of Reusable Object-Oriented Software"*** 의 저자들을 가리키는 말.

원 저자들은 종종 ***"Gang of Four"(GoF)*** 로 불리며, 원래의 패턴들은 ***GoF 패턴*** 이라고도 불린다. 예시가 주로 C++(과 Smalltalk)에서 인용되었지만, 그들의 아이디어는 C#과 같은 어떠한 객체 지향 언어에도 적용할 수 있다.

## Learning Design Patterns
디자인 패턴을 학습하는 것이 게임 개발자에게는 필수적이지 않을 수 있지만, 더 나은 개발자가 되는 데 도움이 될 것. 결국, 디자인 ***패턴*** 이라고 불리는 이유는 그것들이 잘 알려진 문제에 대한 공통적인 해결책이기 때문. 소프트웨어 엔지니어들은 개발의 정상적인 과정에서 이러한 패턴을 계속해서 재발견한다. 이미 의도하지 않게 이러한 패턴 중 일부를 구현했을 수도 있다. 이러한 패턴을 찾아내도록 스스로를 훈련시켜라. 이것을 수행하는 것은 다음과 같은 이점을 줄 수 있다:

### 객체 지향 프로그래밍을 배울 것
	디자인 패턴은 어떤 심오한 StackOverflow 게시물에 숨겨진 비밀이 아니다. 
	그것들은 개발 중에 매일 마주치는 장애물을 극복하기 위한 일반적인 방법이다. 
	디자인 패턴은 많은 다른 개발자들이 동일한 문제에 접근한 방식을 알려줄 수 있다. 
	당신이 패턴을 사용하지 않더라도, 다른 누군가는 사용하고 있다.

### 다른 개발자들과 대화하기
	팀 내에서 소통할 때, 패턴은 약어처럼 사용될 수 있다. 
	"command pattern" 이나 "object pool"을 언급하면, 
	경험있는 개발자는 무엇을 구현하려고 하는지 정확히 알 것이다.

### 새로운 프레임워크 탐색하기
	내장 패키지를 가져오거나 에셋 스토어에서 무언갈 임포트할 때, 
	여기서 논의된 하나 이상의 패턴을 불가피하게 마주치게 된다. 
	디자인 패턴을 인식하는 것은 새로운 프레임워크가 작동하는지 이해하는 데 도움이 되며, 
	그것이 생성된 사고 과정을 파악하는 데에도 유용하다.

디자인 패턴의 유용성은 그 맥락에 따라 다르다. 각 패턴은 특정 상황에서 이점을 제공하지만, 그와 동시에 단점도 있다. S/W 개발에서의 모든 결정은 타협을 수반한다.

## Patterns within Unity
유니티는 직접 구현할 필요 없이, 이미 여러가지 확립된 게임 개발 패턴을 구현하고 있다.

### Game Loop
모든 게임의 Core에는 시계 속도와 독립적으로 기능해야 하는 무한 루프가 있다. 게임 어플리케이션을 구동하는 H/W의 성능이 크게 다를 수 있기 때문에. 다양한 속도의 컴퓨터를 고려하여, 게임 개발자들은 fixed timestep과 이전 프레임 이후로 얼마나 많은 시간이 지났는지를 측정하는 엔진이 사용하는 변수 timestep을 자주 사용해야 한다.

유니티에서 이를 처리하기 때문에, 이를 직접 구현할 필요는 없다. `Update`, `LateUpdate` 그리고 `FixedUpdate와` 같은 `MonoBehaviour` 메소드들을 활용해 게임 플레이를 관리하기만 하면 된다.
### Update
게임 애플리케이션에서는 종종 각 객체의 행동을 한 프레임씩 업데이트해야 한다. Unity에서 이를 수동으로 재현할 수 있지만, `MonoBehaviour` 클래스는 이 작업을 자동으로 수행한다. 단지 적절한 `Update`, `LateUpdate`, 또는 `FixedUpdate` 메소드를 사용하여 게임 시계의 한 틱(tick)에 맞춰 `GameObject`와 컴포넌트를 수정하기만 하면 된다.
### Prototype
원본 객체에 영향을 주지 않으면서 객체를 복사할 필요가 있을 때 사용하는 생성 패턴이다. 이 패턴은 객체를 복제하고 클론하여 자신과 유사한 다른 객체를 만드는 문제를 해결한다. 이를 통해 게임 내 모든 유형의 객체를 생성하기 위해 별도의 클래스를 정의하는 것을 피할 수 있습니다

Unity의 프리팹(Prefab) 시스템은 `GameObject`에 대한 프로토타이핑의 한 형태를 구현한다. 이 시스템을 사용하면, 컴포넌트가 포함된 템플릿 객체를 복제할 수 있다. 특정 속성을 오버라이드하여 `프리팹 변형(Prefab Variants)`을 생성하거나, 계층 구조를 생성하기 위해 다른 프리팹 내에 `프리팹을 중첩`시킬 수 있다. 프리팹을 격리 상태 또는 컨텍스트에서 편집할 수 있는 특별한 프리팹 편집 모드를 사용할 수 있다.
### Component 
유니티를 활용하는 사람 중 대부분이 알고 있는 이 패턴은, 다중 책임을 가진 큰 클래스를 생성하는 대신, 각각 하나의 일만 수행하는 작은 컴포넌트를 구축하는 것이다.

컴포넌트를 선택하여 조합함으로써 복잡한 행동을 결합할 수 있다. 물리를 위해 `Rigidbody와` `Collider` 컴포넌트를 추가하고, 3D 기하학을 위해 `MeshFilter와` `MeshRenderer`를 추가한다. 각 `GameObject`는 그것의 컴포넌트 모음만큼이나 풍부하고 독특하다.

물론, Unity가 모든 것을 해결해주지는 않는다. 필연적으로 내장되어 있지 않은 다른 패턴들이 필요할 것이다. 

## 참고한 자료
[유니티 E-Book](https://unity.com/kr/resources/level-up-your-code-with-game-programming-patterns)