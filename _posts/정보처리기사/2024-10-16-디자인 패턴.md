---
title: 디자인 패턴
date: 2024-10-16 +0900
categories: [정보처리기사]
tags: [정보처리기사, 디자인 패턴]
math: true
mermaid: true
---

## 디자인 패턴 Design Pattern

**모듈 간의 관계 및 인터페이스를 설계할 때 참조할 수 있는 전형적인 해결방식 또는 예제** 

- 문제 및 배경, 실제 적용된 사례, 재사용 가능한 샘플 코드 등으로 구성.
- *“Don’t reinvent the wheel”*
- GoF의 디자인 패턴은 생성 패턴, 구조 패턴, 행위 패턴으로 구분됨.

## 생성 패턴 Creational Pattern

**클래스나 객체의 생성과 참조 과정을 정의하는 패턴**

### 추상 팩토리 Abstract Factory

- 구체적인 클래스에 의존하지 않고, **인터페이스**를 통해 서로 **연관/의존하는 객체들의 그룹**으로 생성하여 추상적으로 표현한다.
- 연관된 서브 클래스를 묶어 한 번에 교체하는 것이 가능하다.
- **사용 예시** : RPG 게임에서 전사, 마법사, 궁수와 같은 다양한 유형의 캐릭터와 무기를 생성할 때
    
    ```csharp
    public interface ICharacterFactory {
        ICharacter CreateCharacter();
        IWeapon CreateWeapon();
    }
    
    public class WarriorFactory : ICharacterFactory {
        public ICharacter CreateCharacter() {
            return new Warrior();
        }
    
        public IWeapon CreateWeapon() {
            return new Sword();
        }
    }
    
    // 새로운 캐릭터와 무기가 추가되면  
    // ICharacterFactory 인터페이스를 상속받는 Factory클래스를 
    // 구현하면 된다.
    ```
    

### 팩토리 메서드 Factory Method

- **객체 생성을 서브 클래스에서 처리**하도록 분리하여 캡슐화한 패턴
- 상위 클래스에서 인터페이스만 정의하고 실제 생성은 서브 클래스가 담당함
- 가상 생성자 (Virtual Constructor) 패턴이라고도 한다.
- **사용 예시** : 다양한 적 캐릭터를 생성하는 경우
    
    ```csharp
    public abstract class EnemyFactory {
        public abstract IEnemy CreateEnemy();
    }
    
    public class GoblinFactory : EnemyFactory {
        public override IEnemy CreateEnemy() {
            return new Goblin();
        }
    }
    
    // 새로운 적 캐릭터가 추가되면
    // EnemyFactory 추상 클래스를 상속받는 Factory 클래스를
    // 구현하면 된다.
    ```
    

### 빌더 Builder

- 작게 분리된 인스턴스를 건축하듯이 **조합**하여 객체를 생성한다.
- 객체의 생성 과정과 표현 방법을 **분리**하고 있어, 동일한 객체 생성에서도 서로 다른 결과를 만들어 낼 수 있다.

### 프로토타입 Prototype

- **원본 객체**를 **복제**하는 방법으로 객체를 생성하는 패턴
- 일반적인 방법으로 객체를 생성하며, 비용이 큰 경우 주로 이용한다.

### 싱글톤 Singleton

- 하나의 객체를 생성하면 생성된 객체를 **어디서든 참조**할 수 있지만, 여러 프로세스가 동시에 참조할 수는 없다.
- 클래스 내에서 인스턴스가 **하나뿐임을 보장**하며, 불필요한 메모리 낭비를 최소화할 수 있다.

---

## 구조 패턴 Structural Pattern

**클래스나 객체들을 조합하여 더 큰 구조로 만드는 패턴**

### 어댑터 Adapter

- **호환성**이 없는 클래스들의 인터페이스를 다른 클래스가 이용할 수 있도록 **변환**해주는 패턴
- 기존의 클래스를 이용하고 싶지만 인터페이스가 일치하지 않을 때 이용한다.

### 브리지 Bridge

- 구현부에서 추상층을 **분리**하여 서로가 **독립적으로 확장**할 수 있도록 구성한 패턴
- 기능과 구현을 두 개의 별도 클래스로 구현한다.

### 컴포지트 Composite

- 여러 객체를 가진 **복합 객체**와 단일 객체를 구분 없이 다루고자 할 때 사용하는 패턴
- 객체들을 **트리 구조**로 구성하여 디렉터리 안에 디렉터리가 있듯이 복합 객체안에 복합 객체가 포함되는 구조를 구현할 수 있다.

### 데코레이터 Decorator

- 객체 간의 **결합**을 통해 능동적으로 **기능들을 확장**할 수 있는 패턴
- 임의의 객체에 부가적인 기능을 추가하기 위해 다른 객체들을 덧붙이는 방식으로 구현

### 퍼사드 Facade

- 복잡한 서브 클래스들을 피해 더 상위에 인터페이스를 구성함으로써 서브 클래스들의 기능을 **간편하게 사용**할 수 있도록 하는 패턴
- 서브 클래스들 사이의 **통합** 인터페이스를 제공하는 Wrapper 객체가 필요하다. 이 Wrapper 객체는 하위 시스템의 복잡한 인터페이스를 감싸 클라이언트가 쉽게 기능에 접근할 수 있게 한다.

### 플라이웨이트 Flyweight

- 인스턴스가 필요할 때마다 매번 생성하는 것이 아니고 가능한 한 **공유**해서 사용함으로써 **메모리를 절약**하는 패턴
- 다수의 유사 객체를 생성하거나 조작할 때 유용하게 사용할 수 있다.

### 프록시 Proxy

- **접근이 어려운 객체**와 여기에 연결하려는 객체 사이에서 인터페이스 역할을 수행하는 패턴으로, **대리자**라고도 불림.
- 내부에서는 객체 간의 복잡한 관계를 단순하게 정리하고 외부에서는 객체의 세부적인 내용을 숨긴다.

---

## 행위 패턴 Behavioral Pattern

**클래스나 객체들이 서로 상호작용하는 방법이나 책임 분배 방법을 정의하는 패턴**

### 책임 연쇄 Chain of Responsibility

- 요청을 처리할 수 있는 객체가 둘 이상 존재하여 한 객체가 처리하지 못하면 다음 객체로 넘어가는 형태의 패턴 **(책임 전이)**
- 요청을 처리할 수 있는 각 객체들이 **고리로** 묶여 있어 요청이 해결될 때까지 고리를 따라 책임이 넘어감

### 커맨드 Command

- 요청을 객체의 형태로 **캡슐화**하여 **재이용**하거나 취소할 수 있도록 요청에 필요한 정보를 저장하거나 로그에 남기는 패턴
- 요청에 상요되는 각종 명령어들을 추상 클래스와 구체 클래스로 분리하여 단순화함.

### 인터프리터 Interpreter

- 언어에 **문법 표현**을 정의하고 **해석**하는데 사용되는 패턴
- SQL이나 통신 프로토콜과 같은 것을 개발할 때 사용한다.

### 반복자 Iterator

- 자료 구조와 같이 접근이 잦은 객체에 대해 동일한 인터페이스를 사용하도록 하는 패턴
- 내부 표현 방법의 노출 없이**(캡슐화)** **순차적인 접근**이 가능함.

### 중재자 Mediater

- 수많은 객체들 간의 복잡한 상호작용을 **캡슐화**하여 객체로 정의하는 패턴
- 객체 사이의 **의존성을 줄여** 결합도를 감소시킬 수 있다.

### 메멘토 Memento

- 특정 시점에서의 객체 **내부 상태를 객체화**함으로써 **(상태 저장)** 이후 요청에 따라 객체를 해당 시점의 상태로 돌릴 수 있는 **(복원)** 기능을 제공하는 패턴
- `ctrl + z` 와 같은 되돌리기 기능을 개발할 때 주로 이용된다.

### 옵저버 Observer

- 한 객체의 **상태가 변화**하면 객체에 상속되어 있는 다른 객체들에게 변화된 상태를 전달하는 패턴
- **일대다의 의존성**을 정의한다.
- 주로 분산된 시스템 간에 이벤트를 생성/발행하고, 이를 수신해야 할 때 이용한다.

### 상태 State

- 객체의 **상태에 따라** 동일한 동작을 다르게 처리해야 할 때 사용하는 패턴
- 객체 상태를 **캡슐화**하고 이를 참조하는 방식으로 처리

### 전략 Strategy

- 동일한 계열의 **알고리즘들을 개별적으로 캡슐화**하여 **상호 교환할 수 있게** 정의하는 패턴
- 클라이언트는 독립적으로 원하는 알고리즘을 선택하여 사용할 수 있으며, 클라이언트에 영향없이 알고리즘의 변경이 가능함

### 템플릿 메소드 Template Method

- 상위 클래스에서 **골격을 정의**하고, 하위 클래스에서 **세부 처리**를 구체화하는 구조의 패턴
- 유사한 서브 클래스를 묶어 공통된 내용을 상위 클래스에서 정의함으로써 코드의 양을 줄이고 유지보수를 용이하게 한다.

### 방문자 Visitor

- 각 클래스들의 데이터 구조에서 **처리 기능**을 분리하여 별도의 클래스로 구성하는 패턴
- 분리된 처리 기능은 각 **클래스를 방문**하여 수행한다.